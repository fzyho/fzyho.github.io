<!DOCTYPE html>
<html><meta charset="utf-8">
<meta name="renderer" content="webkit">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">


<meta name="keywords" content="">
<meta name="description" content="">

<title>动态规划回顾</title>


<meta name="generator" content="Hugo 0.102.3" />




<link rel="stylesheet" href="/css/main.min.css">
<div class="fixed-header-slide">
    <div class="fixed-header-wrap">
        <header class="header">
            <nav class="nav">
                <div class="logo">
                    <a href="https://fzyho.github.io/" title="Lzero的小站">Lzero的小站</a>
                </div>
                <ul class="menu" id="menu" onscroll="menu_on_scroll()">
                    <li>
                        <a href="https://fzyho.github.io/archives" title="Archive">
                            <span>Archive</span>
                        </a>
                    </li>
                    <li>
                        <a href="https://fzyho.github.io/brochures" title="Brochure">
                            <span>Brochure</span>
                        </a>
                    </li></ul>
            </nav>
        </header>
    </div>
</div><body>
		<main class="content">







  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3&#43;Aro6EYUG4&#43;cU&#43;KJWu/X" crossorigin="anonymous">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c&#43;Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI&#43;sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC&#43;Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"></script>


<script>
  document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    
    
    var tables = document.querySelectorAll('.post-body > table');
    for (let i = 0; i < tables.length; i++) {
      var table = tables[i];
      var wrapper = document.createElement('div');
      wrapper.className = 'table-wrapper';
      table.parentElement.replaceChild(wrapper, table);
      wrapper.appendChild(table);
    }
    


    
    
      var mathElements = document.getElementsByClassName('math');
      var options = {
        delimiters: [
          { left: "$$", right: "$$", display: true },
          { left: "$$\n", right: "\n$$", display: true },
          { left: "$", right: "$", display: false },
        ],
      };

      renderMathInElement(document.querySelector('.post-body'), options);
    
    
  });
</script>


<div class="wrapper-toc">
    <div class="toc">
		
		
		
			<div class="toc-content">
			
				
				
				
				<label style="margin: auto;">-Catalogue-</label>
				
				
				<ul></ul>
					
						
						
							
								
								
								
								
									
										<ul>
									
								
								
									<li>
										<a href="#%e7%ae%80%e5%8c%96%e7%9a%84%e8%83%8c%e5%8c%85%e9%97%ae%e9%a2%98" onclick="onNavClick(`#简化的背包问题-nav`)" id="简化的背包问题-nav" class="animated-visibility">
											简化的背包问题
										</a>
									</li>
								
								
							
						
					
						
						
							
								
								
								
								
									
										<ul>
									
								
								
									<li>
										<a href="#%e5%9b%9e%e6%ba%af%e6%b3%95" onclick="onNavClick(`#回溯法-nav`)" id="回溯法-nav" class="animated-visibility">
											回溯法
										</a>
									</li>
								
								
							
						
					
						
						
							
								
								
								
								
								
									<li>
										<a href="#%e5%89%aa%e6%9e%9d" onclick="onNavClick(`#剪枝-nav`)" id="剪枝-nav" class="animated-visibility">
											剪枝
										</a>
									</li>
								
								
							
						
					
						
						
							
								
								
								
									
										</ul>
									
								
								
								
									<li>
										<a href="#%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92" onclick="onNavClick(`#动态规划-nav`)" id="动态规划-nav" class="animated-visibility">
											动态规划
										</a>
									</li>
								
								
							
						
					
						
						
							
								
								
								
								
									
										<ul>
									
								
								
									<li>
										<a href="#%e7%8a%b6%e6%80%81%e8%bd%ac%e7%a7%bb" onclick="onNavClick(`#状态转移-nav`)" id="状态转移-nav" class="animated-visibility">
											状态转移
										</a>
									</li>
								
								
							
						
					
						
						
							
								
								
								
								
								
									<li>
										<a href="#%e7%8a%b6%e6%80%81%e8%bd%ac%e7%a7%bb%e6%96%b9%e7%a8%8b" onclick="onNavClick(`#状态转移方程-nav`)" id="状态转移方程-nav" class="animated-visibility">
											状态转移方程
										</a>
									</li>
								
								
							
						
					
						
						
							
								
								
								
									
										</ul>
									
								
								
								
									<li>
										<a href="#%e6%80%bb%e7%bb%93" onclick="onNavClick(`#总结-nav`)" id="总结-nav" class="animated-visibility">
											总结
										</a>
									</li>
								
								
							
						
					
				</ul>
			</div>
		
    </div>
</div>


<div class="post-list">
	<div class="single-post">
		<div class="post-head-wrapper">
			<div class="post-title">
				动态规划回顾
				
				<div class="post-meta">
    <time class="post-meta-date" itemprop="datePublished">
        2021-06-29
    </time>

    <ul class="post-meta-tags">
        #
        
        
        
            <li><a href="https://fzyho.github.io/tags/%E7%AE%97%E6%B3%95/" title="算法">算法</a></li>
        
            <li><a href="https://fzyho.github.io/tags/%E9%9A%8F%E6%9C%BA/" title="随机">随机</a></li>
        
    </ul>
</div>
			</div>
		</div>
        
		<div class="post-body-wrapper">
			<div class="post-body" v-pre>
				
				
				<p>最近打算重新复习基础逻辑方面的知识，对于一些有趣或者复杂的知识点打算较为详细地记录下来，以便后面继续回顾。此文便是出于重新理解和整理动态规划的知识点而写作的。</p>
<p>什么是动态规划(Dynamic Programming)？动态规划是一种思想，一种运筹决策的方法。事实上许多能用动态规划解决的问题，同样可以使用<strong>回溯(backtracking)法</strong>解决。只是回溯法的时间复杂度高，而动态规划的时间复杂度低，即效率高，但相对的空间复杂度就可能会高一些。</p>
<h2 id="简化的背包问题">简化的背包问题<a hidden class="anchor" aria-hidden="true" href="#简化的背包问题">#</a></h2>
<p>一般理解动态规划，我喜欢从<strong>0-1背包问题</strong>出发：<em>一个可承重$Wkg$的背包，现将$m$个重量不等的物品放入背包中，问在不超过背包所能装载重量的前提下，怎么放物品能让背包中物品的总重量最大。</em></p>
<h3 id="回溯法">回溯法<a hidden class="anchor" aria-hidden="true" href="#回溯法">#</a></h3>
<p>对于上述背包问题，背包的重量只是一个限制条件，我们需要进行操作的是物品。每个物品都有放入和不放入两种选择。回溯算法的方式就是通过<strong>穷举所有放入不超重的情况，记录当中最接近极限承重</strong>$Wkg$<strong>的结果</strong>。用代码表示逻辑如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">BAG_LOAD_BEARING</span> <span class="o">=</span> <span class="n">100</span><span class="o">;</span> <span class="c1">// 背包的最大承重(kg)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">getFloorWeight</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">itemsWeight</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">itemsWeight</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">calc</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">itemsWeight</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">calc</span><span class="o">(</span><span class="kt">int</span> <span class="n">itemIndex</span><span class="o">,</span> <span class="kt">int</span> <span class="n">bagCurWeight</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">itemsWeight</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 达到承重极限 或者 已经对所有物品做出选择后，返回当前背包重量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">bagCurWeight</span> <span class="o">==</span> <span class="n">BAG_LOAD_BEARING</span> <span class="o">||</span> <span class="n">itemIndex</span> <span class="o">==</span> <span class="n">itemsWeight</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">bagCurWeight</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 选择不装入下一个
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">notPutWeight</span> <span class="o">=</span> <span class="n">calc</span><span class="o">(</span><span class="n">itemIndex</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">bagCurWeight</span><span class="o">,</span> <span class="n">itemsWeight</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 未超过超过背包承重极限时，选择装入下一个
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">putWeight</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">nextPutBagWeight</span> <span class="o">=</span> <span class="n">bagCurWeight</span> <span class="o">+</span> <span class="n">itemsWeight</span><span class="o">[</span><span class="n">itemIndex</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">nextPutBagWeight</span> <span class="o">&lt;=</span> <span class="n">BAG_LOAD_BEARING</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">putWeight</span> <span class="o">=</span> <span class="n">calc</span><span class="o">(</span><span class="n">itemIndex</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">nextPutBagWeight</span><span class="o">,</span> <span class="n">itemsWeight</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 返回二者间的最大值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">notPutWeight</span><span class="o">,</span> <span class="n">putWeight</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如上是回溯法的思路下实现的代码逻辑，可以看出，其实回溯就是使用递归的方式，穷举搜索所有可能的装法，然后找出满足条件的最大值。并且回溯算法的时间复杂度是指数级的，假若物品的数量有个几十上百个，普通的计算机就无法短时间完成计算了。</p>
<h3 id="剪枝">剪枝<a hidden class="anchor" aria-hidden="true" href="#剪枝">#</a></h3>
<p>普通的回溯法效率很低，因此需要进行优化来降低时间复杂度。回顾上面回溯法的思路——对于每个物品我们都有放入背包和不放入两种选择。假设物品的重量依次是：$[3,3,1,&hellip;]$，由此可以得到如下<strong>二元决策树</strong>：</p>
<p><img src="/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9B%9E%E9%A1%BE/%E4%BA%8C%E5%8F%89%E5%86%B3%E7%AD%96%E6%A0%91.png" alt="二叉决策树"></p>
<p>可以看出，图中有两个相同的分支(2,5)，因此我们可以尝试通过记录分支状态——每次进行决策前判断当前状态是否重复出现过——来将其中重复的分支去掉，即<strong>剪枝</strong>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">getFloorWeight</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">itemsWeight</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">itemsWeight</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span><span class="o">[][]</span> <span class="n">stateMarker</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">itemsWeight</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="n">BAG_LOAD_BEARING</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">calc</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">itemsWeight</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">calc</span><span class="o">(</span><span class="kt">int</span> <span class="n">itemIndex</span><span class="o">,</span> <span class="kt">int</span> <span class="n">bagCurWeight</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">itemsWeight</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">bagCurWeight</span> <span class="o">==</span> <span class="n">BAG_LOAD_BEARING</span> <span class="o">||</span> <span class="n">itemIndex</span> <span class="o">==</span> <span class="n">itemsWeight</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">bagCurWeight</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">stateMarker</span><span class="o">[</span><span class="n">itemIndex</span><span class="o">][</span><span class="n">bagCurWeight</span><span class="o">]){</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="o">;</span> <span class="c1">// 重复状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span> 
</span></span><span class="line"><span class="cl">    <span class="n">stateMarker</span><span class="o">[</span><span class="n">itemIndex</span><span class="o">][</span><span class="n">bagCurWeight</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span> <span class="c1">// 记录状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="c1">// 后续代码如 上述回溯法所示一致
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如上，通过记录状态来去掉重复分支逻辑，从而提高计算效率，这样的方式本质上也是一种空间换时间的做法。</p>
<h2 id="动态规划">动态规划<a hidden class="anchor" aria-hidden="true" href="#动态规划">#</a></h2>
<p>动态规划和带有剪枝的回溯法在性能上二者并没有大的区别，其最大的区别应该是在思考方式上，也就是实现逻辑上的区别。动态规划是自底向上的，通过子问题的最优解来推导出问题的最优解，因此常常是可以使用循环实现；而回溯法则是自顶向下的，将一个大问题逐渐拆解成小问题，因此常常是递归。</p>
<h3 id="状态转移">状态转移<a hidden class="anchor" aria-hidden="true" href="#状态转移">#</a></h3>
<p>动态规划是一个多阶段决策的解决方法，通过决策将输入状态转为新的状态，我们不用关心输入状态是怎么来的，也不关心其前一个状态是什么——这也就是动态规划的<strong>无后效性</strong>。因此其实动态规划的核心要点就是——定义好状态是什么，以及决策的逻辑。而动态规划比之回溯、穷举的优势就在于决策后得到的状态可能是重复的。通过对重复的状态进行优化，就可以得到时间复杂度的降低。</p>
<p>其实上述二叉树就是一个很好的状态转移的具象样例——每层都是对同物品的不同决策，然后基于上一层节点的状态，来推导决策出当前的状态集合。我们还可以将这种状态转移的过程通过表格的方式展示。假设物品的重量依次是：$[3,3,1,4,5]$，背包最大承重为9kg，则可得到如下表：</p>
<p><img src="/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9B%9E%E9%A1%BE/%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E8%A1%A8.png" alt="状态转移表"></p>
<p>如上述图，对物品1-&gt;5依次进行决策，最终可以看出其标志<strong>1</strong>的格子与前面的二叉决策树的节点是一致的。然后将表格转为一个二维的boolean数组<code>states[items.length][bagLoadBearing]</code>，表格填写的过程转化为代码逻辑，即可得到对应的实现。需要注意的是，状态转化需要有一个最开始的输入状态，在本例中即为第一个物品的放入/不放入决策。这个在初始时进行设置，然后循环中往下轮询决策。</p>
<p>不过实际上，上述逻辑还可以进一步进行优化——我们关注的重点只有背包的重量，如上图表格中，<code>非1</code>的格子其实是无用。关注的只有重量，因此我们应该可以只用一个一维数组来记录重量状态：当<code>state</code>为<code>true</code>时，就表示此状态在前面的决策中已出现过，我们可以复用此状态。动态规划具有无后效性，即不理会状态是如何出现的，我们只需对状态进行决策。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">int</span> <span class="nf">getFloorWeight</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">itemWeights</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">boolean</span><span class="o">[]</span> <span class="n">weightMarkStates</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">BAG_LOAD_BEARING</span> <span class="o">+</span> <span class="n">1</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 初始流程，先对第一个物品做决策
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">weightMarkStates</span><span class="o">[</span><span class="n">0</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">itemWeights</span><span class="o">[</span><span class="n">0</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">BAG_LOAD_BEARING</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">weightMarkStates</span><span class="o">[</span><span class="n">itemWeights</span><span class="o">[</span><span class="n">0</span><span class="o">]]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 循环中进行状态转移
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">itemWeights</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// bagWeight要从大到小进行处理，从小到大会出现错误覆盖问题
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>       <span class="kt">int</span> <span class="n">bagWeight</span> <span class="o">=</span> <span class="n">BAG_LOAD_BEARING</span> <span class="o">-</span> <span class="n">itemWeights</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(;</span> <span class="n">bagWeight</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">;</span> <span class="n">bagWeight</span><span class="o">--)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 输入状态有记录，转移(即将物品放入背包)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">weightMarkStates</span><span class="o">[</span><span class="n">bagWeight</span><span class="o">])</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">weightMarkStates</span><span class="o">[</span><span class="n">bagWeight</span> <span class="o">+</span> <span class="n">itemWeights</span><span class="o">[</span><span class="n">i</span><span class="o">]]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 从大到小，输出记录到的最大承重
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">BAG_LOAD_BEARING</span><span class="o">;</span> <span class="n">weight</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">;</span> <span class="n">weight</span><span class="o">--)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">weightMarkStates</span><span class="o">[</span><span class="n">weight</span><span class="o">])</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">weight</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>大家可能注意到，代码中在枚举背包容量<code>bagWeight</code>时，采用的是逆序的方式(从大到小)来进行，这是因为同一个循环的<code>bagWeight</code>的枚举应该是互不影响的。若使用正序，则同一循环中会出现<code>bagWeight + itemWeights[i]</code>设置为<code>true</code>导致后面<code>bagWeight</code>判断为<code>true</code>而错误提前设置的问题。</p>
<h3 id="状态转移方程">状态转移方程<a hidden class="anchor" aria-hidden="true" href="#状态转移方程">#</a></h3>
<p>状态转移方程法与回溯/递归类似——通过分析某个问题如何通过子问题来递归/迭代求解，也就是所谓的<strong>最优子结构</strong>。根据最优子结构，我们可以推导出相应的公式，也就是<strong>状态转移方程</strong>。状态转移是动态规划的核心，能写出状态转移方程，那动态规划问题基本上就解决了(剩下的就是转成代码的形式)。</p>
<p>以上述一直分析的0-1背包问题为例，经过上述一连串的分析，我们不难得出其状态$f(w)$的状态转移方程为：
$$
f(w) = max(f(w), f(w - W_{item}(i)) + W_{item}(i))
$$
其中，$f(w)$表示$n$件物品，背包承重$w$情况下的最优解；$W_{item}(i)$表示第$i$个物品的重量，故$f(w - W_{item}(i))$即对物品$i$进行决策时，剩余背包承重的最优解，即前面代码中的<code>bagWeight</code>枚举。</p>
<p>现在倘若升级一点难度，除了考虑背包重量和物品重量，还需考虑物品的价值——问背包中物品价值最大可为多少？这个问题就将状态的定义从<strong>重量</strong>改为了<strong>价值</strong>。但引入的物品价值的概念并没有对背包增加什么限制，其实相当于前面状态转移小节中的代码中的<code>weightMarkStates</code>变为一个整型数据<code>int[]</code>，记录该背包重量下的最优解。即状态转移方程为：
$$
f(w) = max(f(w), f(w - W_{item}(i)) + V_{item}(i))
$$
其中，$V_{item}(i)$表示物品$i$的价值。</p>
<p>背包算法还有多种变形问题，比如完全背包问题，多重背包问题等等。需要考虑的影响因素/变量也会变多变复杂，无法使用决策树或者状态表去具象化处理。此时，状态转移方程的推导就更加困难。但一旦状态转移方程建立起来了，问题也就迎刃而解了。</p>
<h2 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h2>

			</div>
			<div class="post-copyright">
				<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">
	<img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" />
</a>
<br />本作品采用
<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>
进行许可。
<br />
转载时请附上原文链接以注明出处，图片在使用时请保留全部内容(可适当缩放)并附上图片所属的文章链接。若进行商业性使用，请先联系笔者获取许可。
			</div>
		</div>
		<div class="post-footer-wrapper">
			<hr class="hr-fade"/>
			<div class="post-comment-wrapper"></div> 
		</div>
	</div>
</div>

</main>
	</body>
</html>

<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Lzero的小站</title>
    <link>http://localhost:1313/posts/</link>
    <description>Recent content in Posts on Lzero的小站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-ch</language>
    <lastBuildDate>Wed, 08 Sep 2021 14:16:15 +0800</lastBuildDate><atom:link href="http://localhost:1313/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>从CLH锁聊聊AQS的设计</title>
      <link>http://localhost:1313/posts/%E4%BB%8Eclh%E9%94%81%E8%81%8A%E8%81%8Aaqs%E7%9A%84%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Wed, 08 Sep 2021 14:16:15 +0800</pubDate>
      
      <guid>http://localhost:1313/posts/%E4%BB%8Eclh%E9%94%81%E8%81%8A%E8%81%8Aaqs%E7%9A%84%E8%AE%BE%E8%AE%A1/</guid>
      <description>AbstractQueuedSynchronizer(简称AQS)是Java并发工具包(JUC)中的锁和同步器(Semophore、CountDownLatch等)的基础，它提供了一个上锁、释放以及锁等待的整体流程框架。AQS是基于一个FIFO的等待队列实现的，它是CLH队列锁(Queuing Lock)的一种变体。因此，秉着从简到深的想法，我们先来了解下CLH队列锁。
CLH Lock CLH队列锁是一种自旋锁。正如名字所描述的，是一种基于队列/链表，通过将线程组织成一个队列的形式来一次进行上锁-处理-释放的同步方式。在队列中，每个线程通过检测其前驱线程是否已完成(获得并释放锁)来判断是否轮到自己。每个线程在不同的存储单元自旋，从而降低cache一致性流，并提高临界区利用率。最后队列FIFO的特性保证了公平性。
一开始，CLHLock的队列只有一个尾部节点。然后线程A和B同时竞争上锁，两线程会调用原子的GetAndSet()的方式，获取尾部节点，并将此节点设置为自己的前驱节点作为，然后将自己线程转成节点插入队列的尾部。完成这些操作后，便进入自旋状态，直到前驱节点释放锁，即字段locked为false。
AQS </description>
    </item>
    
    <item>
      <title>动态规划回顾</title>
      <link>http://localhost:1313/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9B%9E%E9%A1%BE/</link>
      <pubDate>Sun, 29 Aug 2021 16:09:24 +0800</pubDate>
      
      <guid>http://localhost:1313/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9B%9E%E9%A1%BE/</guid>
      <description>最近打算重新复习基础逻辑方面的知识，对于一些有趣或者复杂的知识点打算较为详细地记录下来，以便后面继续回顾。此文便是出于重新理解和整理动态规划的知识点而写作的。
什么是动态规划(Dynamic Programming)？动态规划是一种思想，一种运筹决策的方法。事实上许多能用动态规划解决的问题，同样可以使用回溯(backtracking)法解决。只是回溯法的时间复杂度高，而动态规划的时间复杂度低，即效率高，但相对的空间复杂度就可能会高一些。
简化的背包问题 一般理解动态规划，我喜欢从0-1背包问题出发：一个可承重$Wkg$的背包，现将$m$个重量不等的物品放入背包中，问在不超过背包所能装载重量的前提下，怎么放物品能让背包中物品的总重量最大。
回溯法 对于上述背包问题，背包的重量只是一个限制条件，我们需要进行操作的是物品。每个物品都有放入和不放入两种选择。回溯算法的方式就是通过穷举所有放入不超重的情况，记录当中最接近极限承重$Wkg$的结果。用代码表示逻辑如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  public static final int BAG_LOAD_BEARING = 100; // 背包的最大承重(kg)  public static int getFloorWeight(int[] itemsWeight) { if (itemsWeight.length == 0) { return 0; } return calc(0, 0, itemsWeight); } private static int calc(int itemIndex, int bagCurWeight, int[] itemsWeight) { // 达到承重极限 或者 已经对所有物品做出选择后，返回当前背包重量  if (bagCurWeight == BAG_LOAD_BEARING || itemIndex == itemsWeight.</description>
    </item>
    
    <item>
      <title>从Shuffle到Sample——谈谈基本的随机算法</title>
      <link>http://localhost:1313/posts/%E4%BB%8Eshuffle%E5%88%B0sample%E8%B0%88%E8%B0%88%E5%9F%BA%E6%9C%AC%E7%9A%84%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/</link>
      <pubDate>Thu, 04 Feb 2021 12:40:47 +0800</pubDate>
      
      <guid>http://localhost:1313/posts/%E4%BB%8Eshuffle%E5%88%B0sample%E8%B0%88%E8%B0%88%E5%9F%BA%E6%9C%AC%E7%9A%84%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/</guid>
      <description>在笔者日常的工作中，常常会碰到类似这样的功能需求：从奖励池(含有$n$种奖励)中随机$m$种给用户，其中$n&amp;gt;m$。
p.s. 笔者的工作语言是Java，因此下面的代码都是以java的方式展现的。
1. 乱序(Shuffle) 最直接的做法可能就是，将该$n$种奖励随机打乱后，选取前$m$种给玩家，即：
1 2 3 4 5  List&amp;lt;Integer&amp;gt; randomPrizeIds(List&amp;lt;Integer&amp;gt; allPrizeIds, int num) { List&amp;lt;Integer&amp;gt; copy = new ArraysList(allPrizeIds); Collections.shuffle(copy); // 打乱列表元素原本的排列顺序 	return copy.subList(0, num); }   但如此做法是否真的足够随机？这就取决于shuffle函数的具体实现逻辑。
1.1 等概率论证 要足够随机，则要求shuffle乱序过程中，每个元素重排到各个位置的概率是相等的。Collections.Shuffle使用的是Knuth-Durstenfeld Shuffle算法(或说Fisher–Yates Shuffle算法)，方法内部实现逻辑大致如下：
1 2 3 4 5 6  void shuffle(List&amp;lt;?&amp;gt; list, Random rnd) { int size = list.size(); for (int i = size; i &amp;gt; 1; i--) { swap(list, i - 1, rnd.</description>
    </item>
    
  </channel>
</rss>

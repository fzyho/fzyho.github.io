<!DOCTYPE html>
<html><meta charset="utf-8">
<meta name="renderer" content="webkit">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">


<meta name="keywords" content="">
<meta name="description" content="">

<title>GO语言笔记</title>

<link rel="icon" href="https://fzyho.github.io/theme/head-icon-3.png">


<meta name="generator" content="Hugo 0.107.0">




<link rel="stylesheet" href="/css/main.min.css">
<div class="fixed-header-slide">
    <div class="fixed-header-wrap">
        <header class="header">
            <nav class="nav">
                <div class="logo">
                    
                    <a href="https://fzyho.github.io/">
                        <img src="/theme/title-1.png" alt="logo" aria-label="logo"
                            height="30px">
                    </a>
                </div>
                <ul class="menu">
                    <li>
                        <a href="https://fzyho.github.io/docs/quic" title="QUIC协议(RFC)">
                            <span>QUIC协议(RFC)</span>
                        </a>
                    </li>
                    <li>
                        <a href="https://fzyho.github.io/archives" title="Archives">
                            <span>Archives</span>
                        </a>
                    </li></ul>
            </nav>
            
        </header>
    </div>
</div><body>
		<main class="content">







  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3&#43;Aro6EYUG4&#43;cU&#43;KJWu/X" crossorigin="anonymous">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c&#43;Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI&#43;sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC&#43;Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"></script>


<script>
  document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    
    
    var tables = document.querySelectorAll('.post-body > table');
    for (let i = 0; i < tables.length; i++) {
      var table = tables[i];
      var wrapper = document.createElement('div');
      wrapper.className = 'table-wrapper';
      table.parentElement.replaceChild(wrapper, table);
      wrapper.appendChild(table);
    }
    


    
    
      var mathElements = document.getElementsByClassName('math');
      var options = {
        delimiters: [
          { left: "$$", right: "$$", display: true },
          { left: "$$\n", right: "\n$$", display: true },
          { left: "$", right: "$", display: false },
        ],
      };

      renderMathInElement(document.querySelector('.post-body'), options);
    
    
  });
</script>


<div class="wrapper-toc">
    <div class="toc">
		
		
		
			<div class="toc-content">
			
				
				
				
				<div style="margin: auto; text-align: center;font-weight: bolder;">- 目录 -</div>
				
				
				<ul></ul>
				
					
					
						
							
							
							
								
									<ul>
								
							
							
							
								<li>
									<a href="#%e8%b0%83%e5%ba%a6%e5%99%a8%e5%92%8cgpm%e6%a8%a1%e5%9e%8b" onclick="onNavClick(`#调度器和gpm模型-nav`)" id="调度器和gpm模型-nav" class="animated-visibility">
										调度器和GPM模型
									</a>
								</li>
							
							
						
					
				
					
					
						
							
							
							
								
									<ul>
								
							
							
							
								<li>
									<a href="#gpm%e6%a8%a1%e5%9e%8b%e7%9a%84%e7%bb%84%e6%88%90" onclick="onNavClick(`#gpm模型的组成-nav`)" id="gpm模型的组成-nav" class="animated-visibility">
										GPM模型的组成
									</a>
								</li>
							
							
						
					
				
					
					
						
							
							
							
							
							
								<li>
									<a href="#go-func%e8%b0%83%e5%ba%a6%e6%b5%81%e7%a8%8b" onclick="onNavClick(`#go-func调度流程-nav`)" id="go-func调度流程-nav" class="animated-visibility">
										go func()调度流程
									</a>
								</li>
							
							
						
					
				
					
					
						
							
							
							
							
							
								<li>
									<a href="#gpm%e7%9a%84%e8%b0%83%e5%ba%a6%e5%9c%ba%e6%99%af" onclick="onNavClick(`#gpm的调度场景-nav`)" id="gpm的调度场景-nav" class="animated-visibility">
										GPM的调度场景
									</a>
								</li>
							
							
						
					
				
					
					
						
							
							
							
							
								
									</ul>
								
							
							
								<li>
									<a href="#%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%92%8cgc" onclick="onNavClick(`#内存分配和gc-nav`)" id="内存分配和gc-nav" class="animated-visibility">
										内存分配和GC
									</a>
								</li>
							
							
						
					
				
					
					
						
							
							
							
								
									<ul>
								
							
							
							
								<li>
									<a href="#gc%e5%9c%ba%e6%99%af" onclick="onNavClick(`#gc场景-nav`)" id="gc场景-nav" class="animated-visibility">
										GC场景
									</a>
								</li>
							
							
						
					
				
					
					
						
							
							
							
							
							
								<li>
									<a href="#%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d" onclick="onNavClick(`#内存分配-nav`)" id="内存分配-nav" class="animated-visibility">
										内存分配
									</a>
								</li>
							
							
						
					
				
					
					
						
							
							
							
							
							
								<li>
									<a href="#%e9%80%83%e9%80%b8%e6%83%85%e5%86%b5" onclick="onNavClick(`#逃逸情况-nav`)" id="逃逸情况-nav" class="animated-visibility">
										逃逸情况
									</a>
								</li>
							
							
						
					
				
					
					
						
							
							
							
							
								
									</ul>
								
							
							
								<li>
									<a href="#go%e5%85%b3%e9%94%ae%e5%ad%97" onclick="onNavClick(`#go关键字-nav`)" id="go关键字-nav" class="animated-visibility">
										Go关键字
									</a>
								</li>
							
							
						
					
				
					
					
						
							
							
							
								
									<ul>
								
							
							
							
								<li>
									<a href="#interface" onclick="onNavClick(`#interface-nav`)" id="interface-nav" class="animated-visibility">
										interface
									</a>
								</li>
							
							
						
					
				
					
					
						
							
							
							
							
							
								<li>
									<a href="#defer" onclick="onNavClick(`#defer-nav`)" id="defer-nav" class="animated-visibility">
										defer
									</a>
								</li>
							
							
						
					
				
					
					
						
							
							
							
							
							
								<li>
									<a href="#make%e5%92%8cnew" onclick="onNavClick(`#make和new-nav`)" id="make和new-nav" class="animated-visibility">
										make和new
									</a>
								</li>
							
							
						
					
				
					
					
						
							
							
							
							
								
									</ul>
								
							
							
								<li>
									<a href="#%e4%be%9d%e8%b5%96%e7%ae%a1%e7%90%86" onclick="onNavClick(`#依赖管理-nav`)" id="依赖管理-nav" class="animated-visibility">
										依赖管理
									</a>
								</li>
							
							
						
					
				
				</ul>
			</div>
		
    </div>
</div>


<div class="post-list">
	<div class="single-post">
		<div class="post-head-wrapper">
			<div class="post-title">
				GO语言笔记
				
			</div>
			<div class="post-meta">
    <time class="post-meta-date" itemprop="datePublished">
        2024-01-14
    </time>

    <ul class="post-meta-tags">
        
        <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 28 24">
    <path d="M9.777 2l11.395 11.395-7.779 7.777-11.393-11.39v-7.782h7.777zm.828-2l-10.604.001v10.609l13.392 13.39 10.607-10.605-13.395-13.395zm-6.019 7.414c-.78-.781-.779-2.047.002-2.827.781-.782 2.047-.781 2.826-.003.783.783.782 2.049 0 2.83-.779.781-2.045.781-2.828 0zm5.824 7.947l-3.537-3.535.709-.707 3.535 3.535-.707.707zm4.242 0l-5.658-5.656.708-.708 5.657 5.657-.707.707zm2.121-2.121l-5.657-5.657.707-.707 5.657 5.657-.707.707z"/>
</svg>
        
        
            <li><a href="https://fzyho.github.io/tags/go/" title="GO">GO</a></li>
        
            <li><a href="https://fzyho.github.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" title="垃圾回收">垃圾回收</a></li>
        
    </ul>
</div>
		</div>
		<div class="post-body-wrapper">
			<div class="post-body" v-pre>
				
				<h2 id="调度器和gpm模型">调度器和GPM模型<a hidden class="anchor" aria-hidden="true" href="#调度器和gpm模型">#</a></h2>
<p>在Go中，线程是运行Goroutine的实体，调度器的功能是把可运行的Goroutine分配到工作线程上。而调度器的运作机制即为GPM模型。</p>
<ul>
<li><strong>G</strong> : 协程(Goroutine)</li>
<li><strong>P</strong> : 处理器(Processor)</li>
<li><strong>M</strong> : 线程(Thread)</li>
</ul>
<h3 id="gpm模型的组成">GPM模型的组成<a hidden class="anchor" aria-hidden="true" href="#gpm模型的组成">#</a></h3>
<ol>
<li>全局队列(Global Queue): 存放等待运行的<strong>G</strong>。全局队列可能被任意的<strong>P</strong>去获取里面的<strong>G</strong>，</li>
<li><strong>P</strong>的本地队列: 和全局队列类似，但存放数量不超过256个。新创建的**G&rsquo;**会先加入本地队列，若本地队列满了，会将本地队列的一般加入全局队列。</li>
<li><strong>P</strong>列表: 所有的<strong>P</strong>都在程序启动时就创建，最多 <strong>GOMAXPROC</strong>个。</li>
<li><strong>M</strong>: 线程运行的是<strong>P</strong>的逻辑——从<strong>P</strong>的本地队列获取G，如果队列为空，则会尝试从全局队列中获取一批G，放入本地队列中；或者从其他本地队列中偷取一批。M的创建时机是 当P中有任务，但没有空闲的M进行关联时，就会创建新的M。</li>
</ol>
<p>程序运行中，有两个释放<strong>G</strong>的情况，一个是<strong>移交机制</strong>，另一个是<strong>抢占机制</strong>。</p>
<ul>
<li>移交(hand off)：当<strong>G</strong>进行系统调用阻塞时，线程会释放绑定的<strong>P</strong>，将<strong>P</strong>交给其他空闲的线程处理，如果没有空闲线程，则会新创建一个。当<strong>G</strong>不阻塞后，会重新走放入队列的流程。</li>
<li>抢占：在Go中，一个协程(Goroutine)最多只占用CPU 10ms时间。</li>
</ul>
<h3 id="go-func调度流程">go func()调度流程<a hidden class="anchor" aria-hidden="true" href="#go-func调度流程">#</a></h3>
<ol>
<li>通过 go func()创建一个Goroutine</li>
<li>新创建的 G 会优先保存在 P的本地队列中，如果 P的本地队列已满(最多256)，则保存在全局队列中</li>
<li>G只能运行在M中。M会从 P的本地队列中弹出一个可执行的G进行处理，若本地队列为空，则从全局队列中获取一批 放入本地队列；若全局队列也为空，则从其他本地队列中偷取</li>
<li>一个M调用 G的过程 是一个循环机制，单个G运行不超过10ms</li>
<li>当运行中的G 发生阻塞操作导致 M阻塞了，runtime会将 此M-P关系解绑，创建/复用空闲线程来关联P</li>
<li>当阻塞的G 唤醒后，会尝试获取一个空闲的P(即无绑定关系的)，加入其中，并进行M-P关联；若获取不到空闲的P，则加入全局队列，M变为空闲的M</li>
</ol>
<ul>
<li>M0：编号为0的主线程，负责执行初始化操作以及启动第一个G(即G0)。启动G0后，M0便和其他M一样</li>
<li>G0：每次启动一个M，创建的第一个Goroutine。G0仅负责调度G，在调度或者系统调度时，会使用M切换到G0，再通过G0进行调度。</li>
</ul>
<h3 id="gpm的调度场景">GPM的调度场景<a hidden class="anchor" aria-hidden="true" href="#gpm的调度场景">#</a></h3>
<ol>
<li>GPM调度器具有局部性。如果G1创建了G2，则G2会优先放在G1所在的本地队列</li>
<li>GPM调度器具有复用性。当一个G执行完后，不管其他P是否空闲，M都一定从绑定的 P的本地队列中获取 G。</li>
<li>全局队列的乱序性。如果当创建的G加入 本地队列时，发现队列已满，会将新创建的G和队列中前一半的G 以乱序的方式移到全局队列中。</li>
<li>M-P的自旋。在创建一个G的时候，会触发唤醒其他空闲的P和M(空闲的线程不会立刻被操作系统回收，而是放到一个休眠线程队列中)。唤醒的P和M会自动关联组合到一起，并执行M中的G0任务，此时状态被称为<strong>自旋</strong>。
<ul>
<li>M从P的队列中获取不到G，就会从全局队列中获取，获取公式为：<code>min(len(GQ) / GOMAXPROCS + 1, cap(LQ) / 2)</code>。</li>
<li>从全局队列也为空时，就会从其他本地队列的队尾获取一半的G。</li>
<li>因为最多只有GOMAXPROCS个P，因此程序中最多只有 GOMAXPROCS 个自旋的线程</li>
</ul>
</li>
</ol>
<h2 id="内存分配和gc">内存分配和GC<a hidden class="anchor" aria-hidden="true" href="#内存分配和gc">#</a></h2>
<h3 id="gc场景">GC场景<a hidden class="anchor" aria-hidden="true" href="#gc场景">#</a></h3>
<p>Go采用的垃圾标记法是 三色标记法。为了能够进行并发标记，需要使用<strong>混合写屏障机制</strong>。</p>
<ol>
<li>GC开始时，将所有栈上的所有对象都扫描并标记为黑色</li>
<li>GC期间，所有栈上创建的对象也标记为黑色</li>
<li>被删除引用的对象以及被添加引用的对象都标记为灰色</li>
</ol>
<p>因此整体GC过程，也是</p>
<ul>
<li>标记RootSet(栈空间、常量、枚举、全局变量等对象)，会STW</li>
<li>并发标记(使用三色标记法)</li>
<li>重新标记，将并发标记时变更引用的对象(灰色标记)重新进行扫描；STW</li>
<li>并发清除未标记(白色)对象</li>
</ul>
<p>并发标记和混合写屏障 也会带来一个问题，就是<strong>浮动垃圾</strong>。因为并发标记过程中变更了引用，可能会导致已经标记为黑色的对象，实际上是没有被引用的垃圾。但本次GC无法回收，只能等下一次GC。</p>
<p>被动触发GC的方式：</p>
<ul>
<li>后台Goroutine监控，当超过2min没有产生 GC时，强制触发GC。</li>
<li>使用步调(Pacing)算法，其核心思想是控制内存增长的比例。</li>
</ul>
<p>观察GC情况，可以使用<code>debug.GCStats</code>和<code>runtime.MemStats</code>获取；或者使用<code>go tool trace</code>工具</p>
<h3 id="内存分配">内存分配<a hidden class="anchor" aria-hidden="true" href="#内存分配">#</a></h3>
<p><code>ulimit -s</code>命令可以查看linux的线程栈大小限制，一般为8192。
Go的大对象(&gt;32kB)会直接在堆上分配，其他的会通过<strong>逃逸分析</strong>来判断应该在堆上分配，还是在栈上分配。
<code>new</code>创建的对象分配的位置还是需要根据逃逸分析的结果确定。</p>
<h3 id="逃逸情况">逃逸情况<a hidden class="anchor" aria-hidden="true" href="#逃逸情况">#</a></h3>
<p>多级间接赋值会导致出现不必要的逃逸，比如</p>
<ul>
<li>形参为指针类型或者切片类型</li>
<li>使用chan传递数据</li>
<li>赋值给切片或者map中的元素，如
<ul>
<li><code>[]interface{}</code>的<code>data[0]=100</code></li>
<li><code>map[string]interface{}</code>的<code>data[&quot;key&quot;]=200</code></li>
<li><code>map[string][]string</code>的<code>data[&quot;key&quot;]</code>=<code>[]string{&quot;value&quot;}</code></li>
<li><code>[]int{}</code>的<code>data[0]=&amp;val</code></li>
</ul>
</li>
</ul>
<h2 id="go关键字">Go关键字<a hidden class="anchor" aria-hidden="true" href="#go关键字">#</a></h2>
<h3 id="interface">interface<a hidden class="anchor" aria-hidden="true" href="#interface">#</a></h3>
<p><strong><code>interface</code>是所有Go语言类型的父类</strong>。<code>func f(x interface{})</code>可以接受任何类型，包括指针。而<code>func f(x *interface{})</code>则只能接受<code>*interface{}</code>类型，即非空接口的地址类型。</p>
<p>接口类型结构体中包含两个字段，类型信息字段(*_type 或者 *itab)以及数据信息指针。所以声明赋值时，只要确定了类型，就不会是空接口类型。</p>
<pre tabindex="0"><code>// 空接口(eface)
var MyInterface interface {
}


// 非空接口
type MyInterface interface {
}
</code></pre><h3 id="defer">defer<a hidden class="anchor" aria-hidden="true" href="#defer">#</a></h3>
<p>defer的执行顺序是后进先出。defer的触发时遇到return或者panic。</p>
<p>return和defer的执行先后是，先执行return语句，再执行defer语句。
如下代码，最终输出结果为`10 1``。当声明的返回值有变量名，会使用变量名，否则会使用内部的匿名变量作为返回值。因此func1函数的t是返回值，而func2则是返回一个匿名变量的值，而不是t。</p>
<pre tabindex="0"><code>func func1() (t int) { // t先初始化为0
    defer func() {
        t =  t * 10
    }()
    return 1; // t设置为1
}

func func2() int {
    t := 1
    defer func() {
        t =  t * 10
    }()
    return t;
}

// 执行结果为：10，1
func main() {
    fmt.Println(func1())
    fmt.Println(func2())
}
</code></pre><p>遇到panic时，会遍历本协程到目前为止遇到过的所有defer语句(<strong>panic之后的defer不会执行，因为还没压栈</strong>)。当遇到recover时，会停止panic，但defer会继续执行</p>
<p>需要注意，defer的函数表达式在入栈时就会确定好实参数值。因此如果在defer的函数表达式的形参中嵌套函数，嵌套的函数会在程序跑到defer声明的时候触发执行。</p>
<pre tabindex="0"><code>func function(index int) {
    fmt.Println(index)
    return index
}

// 执行结果为：3 4 2 1
func main() {
    defer function(1, function(3))
    defer function(2, function(4))
}
</code></pre><h3 id="make和new">make和new<a hidden class="anchor" aria-hidden="true" href="#make和new">#</a></h3>
<p>new只接受一个参数，该参数表示一种类型，分配好内存并设置好类型默认值后，返回内存对应地址的指针。</p>
<pre tabindex="0"><code>type user struct {
    lock sync.Mutex
    name string
    age int
}

// 输出结果：&amp;{{0 0} 张三 0}
func main() {
    u := new(user)
    u.lock.Lock()
    u.name = &#34;张三&#34;
    u.lock.Unlock()
    fmt.Println(u)
}
</code></pre><p>make也是用于内存分配，但只能作用于chan、map、slice的内存创建。且它的返回类型就是这三种类型，而不是指针。当然new也可以用于上述三种类型的内存分配。</p>
<h2 id="依赖管理">依赖管理<a hidden class="anchor" aria-hidden="true" href="#依赖管理">#</a></h2>

			</div>
			<div class="post-copyright">
				<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">
	<img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" />
</a>
<br />本作品采用
<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>
进行许可。
<br />
转载时请附上原文链接以注明出处，图片在使用时请保留全部内容(可适当缩放)并附上图片所属的文章链接。若进行商业性使用，请先联系笔者获取许可。
			</div>
		</div>
		<div class="post-footer-wrapper">
			<hr class="hr-fade"/>
			<div class="post-comment-wrapper"></div> 
		</div>
	</div>
</div>

</main>
	</body>
</html>
